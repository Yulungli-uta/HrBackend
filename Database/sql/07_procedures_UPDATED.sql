-- AUTOGENERATED: procedimientos con ajustes heurísticos a columnas que ya no existen.
GO

/*** Procedure: HR.sp_ApproveNightOvertime ***/
CREATE PROCEDURE HR.sp_ApproveNightOvertime
    @OvertimeID INT,
    @FirstApprover INT,
    @SecondApprover INT
AS
BEGIN
    SET NOCOUNT ON;
    UPDATE HR.tbl_Overtime
    SET ApprovedBy = @FirstApprover,
        SecondApprover = @SecondApprover,
        Status = 'Verified'
    WHERE OvertimeID = @OvertimeID AND OvertimeType = 'Nocturna';
    SELECT @@ROWCOUNT AS RowsAffected;
END
GO

/* ---------------------------------------------------------------------------
   sp_RequestVacation
   Crea una solicitud de vacaciones y permiso asociado (tipo 'Vacaciones').
   Valida contra saldo simple (Último registro de HR.tbl_Vacations).
--------------------------------------------------------------------------- */
IF OBJECT_ID('HR.sp_RequestVacation','P') IS NOT NULL DROP PROCEDURE HR.sp_RequestVacation;
GO
/*** Procedure: HR.sp_ApprovePermission ***/
CREATE PROCEDURE HR.sp_ApprovePermission
    @PermissionID INT,
    @ApproverID INT,
    @Approve BIT,
    @Reason NVARCHAR(MAX) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    UPDATE HR.tbl_Permissions
    SET Status = CASE WHEN @Approve = 1 THEN 'Approved' ELSE 'Rejected' END,
        ApprovedBy = @ApproverID,
        Justification = COALESCE(Justification,'') + ISNULL(' | ' + @Reason,'')
    WHERE PermissionID = @PermissionID;
    SELECT @@ROWCOUNT AS RowsAffected;
END
GO

/* ---------------------------------------------------------------------------
   sp_CalculateSubsidies
   Calcula y asigna subsidios estándar (p. ej. Transporte) para un período.
   - Parámetro DepartmentID permite limitar a un área
   - Idempotente por PayrollID + Concepto
--------------------------------------------------------------------------- */
IF OBJECT_ID('HR.sp_CalculateSubsidies','P') IS NOT NULL DROP PROCEDURE HR.sp_CalculateSubsidies;
GO
/*** Procedure: HR.sp_ApproveTimeRecovery ***/
CREATE PROCEDURE HR.sp_ApproveTimeRecovery
    @RecoveryPlanID INT,
    @ApproverID INT
AS
BEGIN
    SET NOCOUNT ON;
    -- (opcional: agregar columna de estado; por ahora, registramos en logs con 0 minutos como "aprobación")
    INSERT INTO HR.tbl_TimeRecoveryLogs(RecoveryPlanID, ExecutedDate, MinutesRecovered, ApprovedBy, ApprovedAt)
    VALUES(@RecoveryPlanID, CAST(SYSDATETIME() AS DATE), 0, @ApproverID, SYSDATETIME());
    SELECT 1 AS Ok, 'Plan de recuperación aprobado (log registrado)' AS Msg;
END
GO

-- Registrar ejecución de recuperación
IF OBJECT_ID('HR.sp_LogTimeRecovery','P') IS NOT NULL DROP PROCEDURE HR.sp_LogTimeRecovery;
GO
/*** Procedure: HR.sp_AssignEmployeeSubsidy ***/
CREATE PROCEDURE HR.sp_AssignEmployeeSubsidy
    @EmployeeID INT,
    @Period CHAR(7),
    @Concept VARCHAR(120),
    @Amount DECIMAL(12,2)
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRY
        BEGIN TRANSACTION;
        IF NOT EXISTS (SELECT 1 FROM HR.tbl_Payroll WHERE EmployeeID=@EmployeeID AND Period=@Period)
        BEGIN
            DECLARE @salary DECIMAL(12,2) = ISNULL((SELECT TOP 1 BaseSalary FROM HR.tbl_Contracts WHERE EmployeeID=@EmployeeID ORDER BY StartDate DESC),0);
            INSERT INTO HR.tbl_Payroll(EmployeeID, Period, BaseSalary) VALUES(@EmployeeID, @Period, @salary);
        END

        DECLARE @payrollID INT = (SELECT PayrollID FROM HR.tbl_Payroll WHERE EmployeeID=@EmployeeID AND Period=@Period);
        IF NOT EXISTS (SELECT 1 FROM HR.tbl_PayrollLines WHERE PayrollID=@payrollID AND LineType='Subsidy' AND Concept=@Concept)
        BEGIN
            INSERT INTO HR.tbl_PayrollLines(PayrollID, LineType, Concept, Quantity, UnitValue, Notes)
            VALUES(@payrollID, 'Subsidy', @Concept, 1, @Amount, NULL);
        END
        COMMIT TRANSACTION;
        SELECT 1 AS Ok, 'Subsidio asignado' AS Msg;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END
GO

/* ---------------------------------------------------------------------------
   sp_ApproveNightOvertime
   Aprueba horas extra de tipo 'Nocturna' (dos aprobadores) y cambia Status a 'Verified'.
--------------------------------------------------------------------------- */
IF OBJECT_ID('HR.sp_ApproveNightOvertime','P') IS NOT NULL DROP PROCEDURE HR.sp_ApproveNightOvertime;
GO
/*** Procedure: HR.sp_BulkImportPunches ***/
CREATE PROCEDURE HR.sp_BulkImportPunches
    @Rows HR.tt_PunchImport READONLY
AS
BEGIN
    SET NOCOUNT ON;
    INSERT INTO HR.tbl_AttendancePunches(EmployeeID, PunchTime, PunchType, DeviceID, Longitude, Latitude)
    SELECT EmployeeID, PunchTime, PunchType, DeviceID, Longitude, Latitude
    FROM @Rows;  -- el trigger HR.trg_Punch_Validations aplicará reglas
    SELECT @@ROWCOUNT AS Imported;
END
GO


/* ---------------------------------------------------------------------------
   4) Subrogaciones y validadores
--------------------------------------------------------------------------- */

-- Validar ventana de subrogación: devuelve conflictos (si existen)
IF OBJECT_ID('HR.sp_ValidateSubrogationWindow','P') IS NOT NULL DROP PROCEDURE HR.sp_ValidateSubrogationWindow;
GO
/*** Procedure: HR.sp_CalculateDailyAttendance ***/
CREATE PROCEDURE HR.sp_CalculateDailyAttendance
    @EmployeeID INT,
    @WorkDate   DATE
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRY
        BEGIN TRANSACTION;

        ;WITH Punches AS (
            SELECT
                PunchTime,
                PunchType,
                ROW_NUMBER() OVER (ORDER BY PunchTime) AS RN
            FROM HR.tbl_AttendancePunches
            WHERE EmployeeID = @EmployeeID
              AND CAST(PunchTime AS date) = @WorkDate
        ),
        Paired AS (
            SELECT
                i.PunchTime AS InTime,
                o.PunchTime AS OutTime
            FROM Punches i
            LEFT JOIN Punches o
              ON o.RN = i.RN + 1
            WHERE i.PunchType = 'In' AND o.PunchType = 'Out'
        )
        SELECT
            @EmployeeID AS EmployeeID,
            @WorkDate   AS WorkDate,
            MIN(InTime)  AS FirstPunchIn,
            MAX(OutTime) AS LastPunchOut,
            SUM(CASE WHEN OutTime IS NOT NULL THEN DATEDIFF(MINUTE, InTime, OutTime) ELSE 0 END) AS TotalMinutes
        INTO #Agg
        FROM Paired;

        DECLARE @first DATETIME2, @last DATETIME2, @total INT;
        SELECT @first = FirstPunchIn, @last = LastPunchOut, @total = ISNULL(TotalMinutes,0) FROM #Agg;

        DECLARE @regular INT = IIF(@total > 480, 480, @total);
        DECLARE @overtime INT = IIF(@total > 480, @total - 480, 0);

        MERGE HR.tbl_AttendanceCalculations AS T
        USING (SELECT @EmployeeID AS EmployeeID, @WorkDate AS WorkDate) AS S
        ON (T.EmployeeID = S.EmployeeID AND T.WorkDate = S.WorkDate)
        WHEN MATCHED THEN UPDATE SET
            FirstPunchIn = @first,
            LastPunchOut = @last,
            TotalWorkedMinutes = @total,
            RegularMinutes = @regular,
            OvertimeMinutes = @overtime,
            Status = 'Approved'
        WHEN NOT MATCHED THEN INSERT (EmployeeID, WorkDate, FirstPunchIn, LastPunchOut, TotalWorkedMinutes, RegularMinutes, OvertimeMinutes, NightMinutes, HolidayMinutes, Status)
        VALUES (@EmployeeID, @WorkDate, @first, @last, @total, @regular, @overtime, 0, 0, 'Approved');

        COMMIT TRANSACTION;
        SELECT 1 AS Ok, 'Asistencia diaria calculada' AS Msg, @total AS TotalMinutes, @overtime AS OvertimeMinutes;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END
GO

/* ---------------------------------------------------------------------------
   sp_CalculateMonthlyPayroll
   Calcula/actualiza la nómina del mes para un empleado (YYYY-MM):
   - Crea cabecera si no existe con salario base vigente
   - Inserta líneas de horas extra (Status='Verified') del mes
   - Evita duplicados de líneas (idempotente por concepto/fecha)
--------------------------------------------------------------------------- */
IF OBJECT_ID('HR.sp_CalculateMonthlyPayroll','P') IS NOT NULL DROP PROCEDURE HR.sp_CalculateMonthlyPayroll;
GO
/*** Procedure: HR.sp_CalculateMonthlyPayroll ***/
CREATE PROCEDURE HR.sp_CalculateMonthlyPayroll
    @EmployeeID INT,
    @Period CHAR(7) -- 'YYYY-MM'
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRY
        BEGIN TRANSACTION;

        DECLARE @first DATE = CONVERT(date, @Period + '-01');
        DECLARE @last  DATE = EOMONTH(@first);

        DECLARE @salary DECIMAL(12,2) =
        (
            SELECT TOP 1 BaseSalary
            FROM HR.tbl_Contracts
            WHERE EmployeeID = @EmployeeID
              AND @first BETWEEN StartDate AND ISNULL(EndDate,'9999-12-31')
            ORDER BY StartDate DESC
        );

        IF NOT EXISTS (SELECT 1 FROM HR.tbl_Payroll WHERE EmployeeID=@EmployeeID AND Period=@Period)
        BEGIN
            INSERT INTO HR.tbl_Payroll(EmployeeID, Period, BaseSalary, Status)
            VALUES(@EmployeeID, @Period, ISNULL(@salary,0), 'Pending');
        END
        ELSE
        BEGIN
            UPDATE HR.tbl_Payroll SET BaseSalary = ISNULL(@salary, BaseSalary) WHERE EmployeeID=@EmployeeID AND Period=@Period;
        END

        DECLARE @payrollID INT = (SELECT PayrollID FROM HR.tbl_Payroll WHERE EmployeeID=@EmployeeID AND Period=@Period);

        ;WITH OT AS (
            SELECT WorkDate, OvertimeType, SUM(ActualHours) AS Hours, MAX(Factor) AS Factor
            FROM HR.tbl_Overtime
            WHERE EmployeeID=@EmployeeID AND Status='Verified' AND WorkDate BETWEEN @first AND @last
            GROUP BY WorkDate, OvertimeType
        )
        INSERT INTO HR.tbl_PayrollLines(PayrollID, LineType, Concept, Quantity, UnitValue, Notes)
        SELECT @payrollID, 'Overtime',
               CONCAT('Horas extra ', OvertimeType, ' ', CONVERT(char(10), WorkDate, 23)) AS Concept,
               Hours, 
               ROUND(ISNULL(@salary,0) / 240.0 * Factor, 2), -- valor hora * factor
               NULL
        FROM OT o
        WHERE NOT EXISTS (
            SELECT 1 FROM HR.tbl_PayrollLines pl
            WHERE pl.PayrollID=@payrollID AND pl.LineType='Overtime' AND pl.Concept=CONCAT('Horas extra ', o.OvertimeType, ' ', CONVERT(char(10), o.WorkDate, 23))
        );

        COMMIT TRANSACTION;
        SELECT 1 AS Ok, 'Nómina calculada/actualizada' AS Msg, @payrollID AS PayrollID;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END
GO

/* ---------------------------------------------------------------------------
   sp_GenerateMonthlyAttendanceReport
   Reporte de asistencia por mes (y opcional por departamento):
   - Devuelve consolidado por empleado con minutos trabajados/extra por día.
--------------------------------------------------------------------------- */
IF OBJECT_ID('HR.sp_GenerateMonthlyAttendanceReport','P') IS NOT NULL DROP PROCEDURE HR.sp_GenerateMonthlyAttendanceReport;
GO
/*** Procedure: HR.sp_CalculateSubsidies ***/
CREATE PROCEDURE HR.sp_CalculateSubsidies
    @Period CHAR(7),
    @DepartmentID INT = NULL,
    @Concept VARCHAR(120) = 'Transporte',
    @Amount DECIMAL(12,2) = 30.00
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRY
        BEGIN TRANSACTION;

        DECLARE @first DATE = CONVERT(date, @Period + '-01');
        ;WITH Emp AS (
            SELECT e.EmployeeID
            FROM HR.tbl_Employees e
            WHERE e.IsActive = 1 AND (@DepartmentID IS NULL OR e.DepartmentID = @DepartmentID)
        )
        SELECT * INTO #Emp FROM Emp;

        DECLARE cur CURSOR LOCAL FOR SELECT EmployeeID FROM #Emp;
        DECLARE @eid INT;
        OPEN cur; FETCH NEXT FROM cur INTO @eid;
        WHILE @@FETCH_STATUS = 0
        BEGIN
            EXEC HR.sp_AssignEmployeeSubsidy @EmployeeID=@eid, @Period=@Period, @Concept=@Concept, @Amount=@Amount;
            FETCH NEXT FROM cur INTO @eid;
        END
        CLOSE cur; DEALLOCATE cur;

        COMMIT TRANSACTION;
        SELECT 1 AS Ok, 'Subsidios calculados/asignados' AS Msg;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END
GO

/* ---------------------------------------------------------------------------
   sp_PlanOvertime
   Registra horas extra planificadas con cálculo automático del factor si no se envía.
--------------------------------------------------------------------------- */
IF OBJECT_ID('HR.sp_PlanOvertime','P') IS NOT NULL DROP PROCEDURE HR.sp_PlanOvertime;
GO
/*** Procedure: HR.sp_ClosePayrollPeriod ***/
CREATE PROCEDURE HR.sp_ClosePayrollPeriod
    @Period CHAR(7),
    @PaymentDate DATE = NULL
AS
BEGIN
    SET NOCOUNT ON;
    UPDATE HR.tbl_Payroll
      SET Status='Reconciled',
          PaymentDate = COALESCE(@PaymentDate, PaymentDate, CAST(SYSDATETIME() AS DATE))
    WHERE Period=@Period;
    SELECT @@ROWCOUNT AS RowsAffected;
END
GO

-- Reapertura de período (de Reconciled a Pending)
IF OBJECT_ID('HR.sp_ReopenPayrollPeriod','P') IS NOT NULL DROP PROCEDURE HR.sp_ReopenPayrollPeriod;
GO
/*** Procedure: HR.sp_EmployeesAboutToVacation ***/
CREATE PROCEDURE HR.sp_EmployeesAboutToVacation
    @WithinDays INT = 15
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @today DATE = CAST(SYSDATETIME() AS DATE);
    DECLARE @limit DATE = DATEADD(DAY, @WithinDays, @today);

    SELECT e.EmployeeID, p.FirstName + ' ' + p.LastName AS EmployeeName, v.StartDate, v.EndDate, v.Status
    FROM HR.tbl_Vacations v
    JOIN HR.tbl_Employees e ON e.EmployeeID = v.EmployeeID
    JOIN HR.tbl_People p ON p.PersonID = e.EmployeeID
    WHERE v.StartDate BETWEEN @today AND @limit
      AND v.Status IN ('Planned','InProgress');
END
GO

-- Permisos pendientes (opcional por departamento)
IF OBJECT_ID('HR.sp_ListPendingPermissions','P') IS NOT NULL DROP PROCEDURE HR.sp_ListPendingPermissions;
GO
/*** Procedure: HR.sp_EmployeesOnLeave ***/
CREATE PROCEDURE HR.sp_EmployeesOnLeave
    @FromDate DATE,
    @ToDate   DATE
AS
BEGIN
    SET NOCOUNT ON;
    SELECT e.EmployeeID, p.FirstName + ' ' + p.LastName AS EmployeeName, v.StartDate, v.EndDate, v.Status
    FROM HR.tbl_Vacations v
    JOIN HR.tbl_Employees e ON e.EmployeeID = v.EmployeeID
    JOIN HR.tbl_People p ON p.PersonID = e.EmployeeID
    WHERE v.StartDate <= @ToDate AND v.EndDate >= @FromDate;
END
GO

-- Empleados próximos a vacacionar (dentro de N días)
IF OBJECT_ID('HR.sp_EmployeesAboutToVacation','P') IS NOT NULL DROP PROCEDURE HR.sp_EmployeesAboutToVacation;
GO
/*** Procedure: HR.sp_GenerateMonthlyAttendanceReport ***/
CREATE PROCEDURE HR.sp_GenerateMonthlyAttendanceReport
    @Period CHAR(7),             -- 'YYYY-MM'
    @DepartmentID INT = NULL     -- NULL = todos
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @first DATE = CONVERT(date, @Period + '-01');
    DECLARE @last  DATE = EOMONTH(@first);

    SELECT 
        e.EmployeeID,
        p.FirstName + ' ' + p.LastName AS EmployeeName,
        d.Name AS Department,
        ac.WorkDate,
        ac.TotalWorkedMinutes,
        ac.RegularMinutes,
        ac.OvertimeMinutes,
        ac.NightMinutes,
        ac.HolidayMinutes,
        ac.Status
    FROM HR.tbl_AttendanceCalculations ac
    JOIN HR.tbl_Employees e ON e.EmployeeID = ac.EmployeeID
    JOIN HR.tbl_People p ON p.PersonID = e.EmployeeID
    LEFT JOIN HR.tbl_Departments d ON d.DepartmentID = e.DepartmentID
    WHERE ac.WorkDate BETWEEN @first AND @last
      AND (@DepartmentID IS NULL OR e.DepartmentID = @DepartmentID)
    ORDER BY Department, EmployeeName, ac.WorkDate;
END
GO

/* ---------------------------------------------------------------------------
   sp_RegisterPersonnelMovement
   Registra un movimiento (Transfer/Promotion/Demotion/Lateral) y actualiza
   el departamento del empleado si aplica.
--------------------------------------------------------------------------- */
IF OBJECT_ID('HR.sp_RegisterPersonnelMovement','P') IS NOT NULL DROP PROCEDURE HR.sp_RegisterPersonnelMovement;
GO
/*** Procedure: HR.sp_GenerateSubsidyComplianceReport ***/
CREATE PROCEDURE HR.sp_GenerateSubsidyComplianceReport
    @Period CHAR(7),
    @DepartmentID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SELECT 
        e.EmployeeID,
        p.FirstName + ' ' + p.LastName AS EmployeeName,
        d.Name AS Department,
        SUM(CASE WHEN pl.LineType='Subsidy' THEN pl.Quantity * pl.UnitValue ELSE 0 END) AS TotalSubsidies
    FROM HR.tbl_Payroll py
    JOIN HR.tbl_PayrollLines pl ON pl.PayrollID = py.PayrollID
    JOIN HR.tbl_Employees e ON e.EmployeeID = py.EmployeeID
    JOIN HR.tbl_People p ON p.PersonID = e.EmployeeID
    LEFT JOIN HR.tbl_Departments d ON d.DepartmentID = e.DepartmentID
    WHERE py.Period = @Period
      AND (@DepartmentID IS NULL OR e.DepartmentID = @DepartmentID)
    GROUP BY e.EmployeeID, p.FirstName, p.LastName, d.Name
    ORDER BY Department, EmployeeName;
END
GO


/* ============================================================================
   UTA – HR Microservicios (SQL Server 2022)
   PROCEDIMIENTOS ADICIONALES SUGERIDOS (recuperación, horarios, reportes, utilitarios)
   Compatibles con: dbUtaSystem_HR_ordered_with_seed.sql
   Todos bajo esquema HR
   ============================================================================ */

USE dbUtaSystem;
GO

/* ---------------------------------------------------------------------------
   1) Schedules & asignaciones
--------------------------------------------------------------------------- */

-- Upsert de asignación de horario con control de solapamiento de vigencias
IF OBJECT_ID('HR.sp_UpsertEmployeeSchedule','P') IS NOT NULL DROP PROCEDURE HR.sp_UpsertEmployeeSchedule;
GO
/*** Procedure: HR.sp_GetActiveSchedule ***/
CREATE PROCEDURE HR.sp_GetActiveSchedule
    @EmployeeID INT,
    @ForDate    DATE
AS
BEGIN
    SET NOCOUNT ON;
    SELECT TOP 1 s.*
    FROM HR.tbl_EmployeeSchedules es
    JOIN HR.tbl_Schedules s ON s.ScheduleID = es.ScheduleID
    WHERE es.EmployeeID = @EmployeeID
      AND @ForDate BETWEEN es.ValidFrom AND ISNULL(es.ValidTo,'9999-12-31')
    ORDER BY es.ValidFrom DESC;
END
GO


/* ---------------------------------------------------------------------------
   2) Recuperación de horas (planificar, aprobar, registrar ejecución, saldos)
--------------------------------------------------------------------------- */

-- Planificar recuperación (con validaciones básicas)
IF OBJECT_ID('HR.sp_PlanTimeRecovery','P') IS NOT NULL DROP PROCEDURE HR.sp_PlanTimeRecovery;
GO
/*** Procedure: HR.sp_GetPayrollBreakdown ***/
CREATE PROCEDURE HR.sp_GetPayrollBreakdown
    @EmployeeID INT,
    @Period CHAR(7)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @pid INT = (SELECT PayrollID FROM HR.tbl_Payroll WHERE EmployeeID=@EmployeeID AND Period=@Period);
    IF @pid IS NULL
    BEGIN
        SELECT 0 AS Exists, NULL AS PayrollID, 0.00 AS TotalEarnings, 0.00 AS TotalOvertime, 0.00 AS TotalSubsidies, 0.00 AS TotalDeductions, 0.00 AS NetPay;
        RETURN;
    END

    SELECT
        1 AS Exists,
        @pid AS PayrollID,
        SUM(CASE WHEN LineType='Earning'  THEN Quantity*UnitValue ELSE 0 END) AS TotalEarnings,
        SUM(CASE WHEN LineType='Overtime' THEN Quantity*UnitValue ELSE 0 END) AS TotalOvertime,
        SUM(CASE WHEN LineType='Subsidy'  THEN Quantity*UnitValue ELSE 0 END) AS TotalSubsidies,
        SUM(CASE WHEN LineType='Deduction'THEN Quantity*UnitValue ELSE 0 END) AS TotalDeductions,
        SUM(CASE WHEN LineType IN ('Earning','Overtime','Subsidy') THEN Quantity*UnitValue ELSE -Quantity*UnitValue END) AS NetPay
    FROM HR.tbl_PayrollLines
    WHERE PayrollID=@pid;
END
GO

-- Cierre de período de nómina (marca Reconciled)
IF OBJECT_ID('HR.sp_ClosePayrollPeriod','P') IS NOT NULL DROP PROCEDURE HR.sp_ClosePayrollPeriod;
GO
/*** Procedure: HR.sp_GetTimeRecoveryBalance ***/
CREATE PROCEDURE HR.sp_GetTimeRecoveryBalance
    @EmployeeID INT
AS
BEGIN
    SET NOCOUNT ON;
    SELECT
        @EmployeeID AS EmployeeID,
        ISNULL(SUM(p.OwedMinutes),0) AS MinutesOwed,
        ISNULL((SELECT SUM(l.MinutesRecovered) FROM HR.tbl_TimeRecoveryLogs l JOIN HR.tbl_TimeRecoveryPlans p2 ON p2.RecoveryPlanID=l.RecoveryPlanID WHERE p2.EmployeeID=@EmployeeID),0) AS MinutesRecovered,
        ISNULL(SUM(p.OwedMinutes),0) - ISNULL((SELECT SUM(l.MinutesRecovered) FROM HR.tbl_TimeRecoveryLogs l JOIN HR.tbl_TimeRecoveryPlans p2 ON p2.RecoveryPlanID=l.RecoveryPlanID WHERE p2.EmployeeID=@EmployeeID),0) AS BalanceMinutes
    FROM HR.tbl_TimeRecoveryPlans p
    WHERE p.EmployeeID = @EmployeeID;
END
GO


/* ---------------------------------------------------------------------------
   3) Asistencia utilitarios
--------------------------------------------------------------------------- */

-- Justificar una picada (crear/actualizar y opcional aprobar)
IF OBJECT_ID('HR.sp_JustifyPunch','P') IS NOT NULL DROP PROCEDURE HR.sp_JustifyPunch;
GO
/*** Procedure: HR.sp_JustifyPunch ***/
CREATE PROCEDURE HR.sp_JustifyPunch
    @PunchID INT,
    @BossEmployeeID INT,
    @Reason VARCHAR(500),
    @Approve BIT = 0
AS
BEGIN
    SET NOCOUNT ON;
    IF EXISTS(SELECT 1 FROM HR.tbl_PunchJustifications WHERE PunchID=@PunchID)
        UPDATE HR.tbl_PunchJustifications
           SET Reason=@Reason, BossEmployeeID=@BossEmployeeID, Approved=@Approve, ApprovedAt=CASE WHEN @Approve=1 THEN SYSDATETIME() ELSE NULL END
         WHERE PunchID=@PunchID;
    ELSE
        INSERT INTO HR.tbl_PunchJustifications(PunchID,BossEmployeeID,Reason,Approved,ApprovedAt)
        VALUES(@PunchID,@BossEmployeeID,@Reason,@Approve,CASE WHEN @Approve=1 THEN SYSDATETIME() ELSE NULL END);

    SELECT 1 AS Ok, 'Justificación registrada' AS Msg;
END
GO

-- Recalcular asistencia en rango (invoca sp_CalculateDailyAttendance por día)
IF OBJECT_ID('HR.sp_RecalculateAttendanceRange','P') IS NOT NULL DROP PROCEDURE HR.sp_RecalculateAttendanceRange;
GO
/*** Procedure: HR.sp_ListPendingPermissions ***/
CREATE PROCEDURE HR.sp_ListPendingPermissions
    @DepartmentID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SELECT pr.PermissionID, e.EmployeeID, p.FirstName + ' ' + p.LastName AS EmployeeName,
           d.Name AS Department, t.Name AS PermissionType, pr.StartDate, pr.EndDate, pr.RequestDate
    FROM HR.tbl_Permissions pr
    JOIN HR.tbl_PermissionTypes t ON t.TypeID = pr.PermissionTypeID
    JOIN HR.tbl_Employees e ON e.EmployeeID = pr.EmployeeID
    JOIN HR.tbl_People p ON p.PersonID = e.EmployeeID
    LEFT JOIN HR.tbl_Departments d ON d.DepartmentID = e.DepartmentID
    WHERE pr.Status = 'Pending'
      AND (@DepartmentID IS NULL OR e.DepartmentID = @DepartmentID)
    ORDER BY pr.RequestDate DESC;
END
GO

-- Desglose de rol de pagos (totales por tipo y neto)
IF OBJECT_ID('HR.sp_GetPayrollBreakdown','P') IS NOT NULL DROP PROCEDURE HR.sp_GetPayrollBreakdown;
GO
/*** Procedure: HR.sp_LogTimeRecovery ***/
CREATE PROCEDURE HR.sp_LogTimeRecovery
    @RecoveryPlanID INT,
    @ExecutedDate DATE,
    @MinutesRecovered INT,
    @ApproverID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    INSERT INTO HR.tbl_TimeRecoveryLogs(RecoveryPlanID, ExecutedDate, MinutesRecovered, ApprovedBy, ApprovedAt)
    VALUES(@RecoveryPlanID, @ExecutedDate, @MinutesRecovered, @ApproverID, CASE WHEN @ApproverID IS NULL THEN NULL ELSE SYSDATETIME() END);
    SELECT SCOPE_IDENTITY() AS RecoveryLogID;
END
GO

-- Resumen de saldo de recuperación
IF OBJECT_ID('HR.sp_GetTimeRecoveryBalance','P') IS NOT NULL DROP PROCEDURE HR.sp_GetTimeRecoveryBalance;
GO
/*** Procedure: HR.sp_PlanOvertime ***/
CREATE PROCEDURE HR.sp_PlanOvertime
    @EmployeeID INT,
    @WorkDate DATE,
    @Hours DECIMAL(5,2),
    @OvertimeType VARCHAR(50),
    @ApproverID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @Factor DECIMAL(5,2) = ISNULL((SELECT Factor FROM HR.tbl_OvertimeConfig WHERE OvertimeType=@OvertimeType),1.25);
    INSERT INTO HR.tbl_Overtime(EmployeeID, WorkDate, OvertimeType, Hours, Status, ApprovedBy, Factor)
    VALUES(@EmployeeID, @WorkDate, @OvertimeType, @Hours, 'Planned', @ApproverID, @Factor);
    SELECT SCOPE_IDENTITY() AS OvertimeID;
END
GO

/* ---------------------------------------------------------------------------
   sp_GenerateSubsidyComplianceReport
   Reporte de cumplimiento de subsidios por período (y opcional por depto).
--------------------------------------------------------------------------- */
IF OBJECT_ID('HR.sp_GenerateSubsidyComplianceReport','P') IS NOT NULL DROP PROCEDURE HR.sp_GenerateSubsidyComplianceReport;
GO
/*** Procedure: HR.sp_PlanTimeRecovery ***/
CREATE PROCEDURE HR.sp_PlanTimeRecovery
    @EmployeeID INT,
    @OwedMinutes INT,
    @PlanDate DATE,
    @FromTime TIME,
    @ToTime TIME,
    @Reason VARCHAR(300) = NULL,
    @CreatedBy INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    IF DATEDIFF(MINUTE, @FromTime, @ToTime) < @OwedMinutes OR DATEDIFF(MINUTE, @FromTime, @ToTime) < 60
        RAISERROR('El bloque planificado debe cubrir al menos los minutos adeudados y ser >= 60 minutos.',16,1);

    -- Evitar plan en vacaciones
    IF EXISTS (
        SELECT 1 FROM HR.tbl_Vacations v
        WHERE v.EmployeeID = @EmployeeID
          AND v.Status IN ('Planned','InProgress')
          AND @PlanDate BETWEEN v.StartDate AND v.EndDate
    )
    BEGIN
        RAISERROR('No se puede planificar recuperación durante vacaciones.',16,1);
        RETURN;
    END

    INSERT INTO HR.tbl_TimeRecoveryPlans(EmployeeID,OwedMinutes,PlanDate,FromTime,ToTime,Reason,CreatedBy)
    VALUES(@EmployeeID,@OwedMinutes,@PlanDate,@FromTime,@ToTime,@Reason,@CreatedBy);

    SELECT SCOPE_IDENTITY() AS RecoveryPlanID;
END
GO

-- Aprobar plan de recuperación
IF OBJECT_ID('HR.sp_ApproveTimeRecovery','P') IS NOT NULL DROP PROCEDURE HR.sp_ApproveTimeRecovery;
GO
/*** Procedure: HR.sp_RecalculateAttendanceRange ***/
CREATE PROCEDURE HR.sp_RecalculateAttendanceRange
    @EmployeeID INT,
    @FromDate DATE,
    @ToDate DATE
AS
BEGIN
    SET NOCOUNT ON;
    IF @ToDate < @FromDate RAISERROR('Rango de fechas inválido.',16,1);

    DECLARE @d DATE = @FromDate;
    WHILE @d <= @ToDate
    BEGIN
        EXEC HR.sp_CalculateDailyAttendance @EmployeeID=@EmployeeID, @WorkDate=@d;
        SET @d = DATEADD(DAY, 1, @d);
    END

    SELECT 1 AS Ok, 'Asistencia recalculada para el rango' AS Msg;
END
GO

-- TVP para importación masiva de picadas
IF TYPE_ID('HR.tt_PunchImport') IS NOT NULL DROP TYPE HR.tt_PunchImport;
GO
CREATE TYPE HR.tt_PunchImport AS TABLE (
    EmployeeID INT NOT NULL,
    PunchTime  DATETIME2(0) NOT NULL,
    PunchType  VARCHAR(10) NOT NULL, -- 'In'/'Out'
    DeviceID   VARCHAR(60) NULL,
    Longitude  DECIMAL(10,7) NULL,
    Latitude   DECIMAL(10,7) NULL
);
GO

-- Importación masiva (respetando trigger de validación)
IF OBJECT_ID('HR.sp_BulkImportPunches','P') IS NOT NULL DROP PROCEDURE HR.sp_BulkImportPunches;
GO
/*** Procedure: HR.sp_RegisterPersonnelMovement ***/
CREATE PROCEDURE HR.sp_RegisterPersonnelMovement
    @EmployeeID INT,
    @ContractID INT,
    @OriginDepartmentID INT = NULL,
    @DestinationDepartmentID INT,
    @MovementDate DATE,
    @MovementType VARCHAR(30),
    @Reason VARCHAR(500) = NULL,
    @DocumentLocation VARCHAR(255) = NULL,
    @CreatedBy INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRY
        BEGIN TRANSACTION;
        INSERT INTO HR.tbl_PersonnelMovements(EmployeeID, ContractID, OriginDepartmentID, DestinationDepartmentID, MovementDate, MovementType, DocumentLocation, Reason, CreatedBy)
        VALUES(@EmployeeID, @ContractID, @OriginDepartmentID, @DestinationDepartmentID, @MovementDate, @MovementType, @DocumentLocation, @Reason, @CreatedBy);

        -- actualizar depto actual
        UPDATE HR.tbl_Employees SET DepartmentID = @DestinationDepartmentID, UpdatedBy = @CreatedBy, UpdatedAt = SYSDATETIME()
        WHERE EmployeeID = @EmployeeID;

        COMMIT TRANSACTION;
        SELECT SCOPE_IDENTITY() AS MovementID;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END
GO

/* ---------------------------------------------------------------------------
   sp_AssignEmployeeSubsidy
   Asegura cabecera de nómina y agrega una línea de subsidio para el período.
   Idempotente por (PayrollID, Concept).
--------------------------------------------------------------------------- */
IF OBJECT_ID('HR.sp_AssignEmployeeSubsidy','P') IS NOT NULL DROP PROCEDURE HR.sp_AssignEmployeeSubsidy;
GO
/*** Procedure: HR.sp_ReopenPayrollPeriod ***/
CREATE PROCEDURE HR.sp_ReopenPayrollPeriod
    @Period CHAR(7)
AS
BEGIN
    SET NOCOUNT ON;
    UPDATE HR.tbl_Payroll SET Status='Pending' WHERE Period=@Period AND Status='Reconciled';
    SELECT @@ROWCOUNT AS RowsAffected;
END
GO
/*** Procedure: HR.sp_RequestVacation ***/
CREATE PROCEDURE HR.sp_RequestVacation
    @EmployeeID INT,
    @StartDate  DATE,
    @EndDate    DATE,
    @ApproverID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @days INT = DATEDIFF(DAY,@StartDate,@EndDate) + 1;
    DECLARE @avail INT = ISNULL((SELECT TOP 1 DaysGranted - DaysTaken FROM HR.tbl_Vacations WHERE EmployeeID=@EmployeeID ORDER BY VacationID DESC),0);
    IF @avail < @days
        RAISERROR('Días de vacaciones insuficientes.',16,1);

    INSERT INTO HR.tbl_Vacations(EmployeeID,StartDate,EndDate,DaysGranted,Status)
    VALUES(@EmployeeID,@StartDate,@EndDate,@days,'Planned');

    DECLARE @vacationID INT = SCOPE_IDENTITY();
    INSERT INTO HR.tbl_Permissions(EmployeeID,PermissionTypeID,StartDate,EndDate,ApprovedBy,Status,VacationID)
    VALUES(@EmployeeID,(SELECT TOP 1 TypeID FROM HR.tbl_PermissionTypes WHERE Name='Vacaciones'),
           @StartDate,@EndDate,@ApproverID,'Pending',@vacationID);

    SELECT @vacationID AS VacationID;
END
GO

/* ---------------------------------------------------------------------------
   sp_ApprovePermission
   Aprueba o rechaza un permiso y registra aprobador.
--------------------------------------------------------------------------- */
IF OBJECT_ID('HR.sp_ApprovePermission','P') IS NOT NULL DROP PROCEDURE HR.sp_ApprovePermission;
GO
/*** Procedure: HR.sp_UpsertEmployeeSchedule ***/
CREATE PROCEDURE HR.sp_UpsertEmployeeSchedule
    @EmployeeID INT,
    @ScheduleID INT,
    @ValidFrom  DATE,
    @ValidTo    DATE = NULL           -- NULL = vigente
AS
BEGIN
    SET NOCOUNT ON;
    IF @ValidTo IS NOT NULL AND @ValidTo < @ValidFrom
        RAISERROR('ValidTo no puede ser menor a ValidFrom',16,1);

    -- chequear solapamiento
    IF EXISTS(
        SELECT 1 FROM HR.tbl_EmployeeSchedules es
        WHERE es.EmployeeID = @EmployeeID
          AND (@ValidTo IS NULL OR es.ValidFrom <= @ValidTo)
          AND (es.ValidTo IS NULL OR es.ValidTo >= @ValidFrom)
    )
    BEGIN
        RAISERROR('Existe una asignación de horario que se solapa en el rango indicado.',16,1);
        RETURN;
    END

    INSERT INTO HR.tbl_EmployeeSchedules(EmployeeID, ScheduleID, ValidFrom, ValidTo)
    VALUES(@EmployeeID, @ScheduleID, @ValidFrom, @ValidTo);
    SELECT SCOPE_IDENTITY() AS EmpScheduleID;
END
GO

-- Obtener horario activo de un empleado para una fecha
IF OBJECT_ID('HR.sp_GetActiveSchedule','P') IS NOT NULL DROP PROCEDURE HR.sp_GetActiveSchedule;
GO
/*** Procedure: HR.sp_ValidateSubrogationWindow ***/
CREATE PROCEDURE HR.sp_ValidateSubrogationWindow
    @SubrogatedEmployeeID INT,
    @StartDate DATE,
    @EndDate DATE
AS
BEGIN
    SET NOCOUNT ON;
    SELECT s.SubrogationID, s.StartDate, s.EndDate
    FROM HR.tbl_Subrogations s
    WHERE s.SubrogatedEmployeeID = @SubrogatedEmployeeID
      AND (@StartDate <= s.EndDate AND @EndDate >= s.StartDate);
END
GO


/* ---------------------------------------------------------------------------
   5) Reportes operativos y de control
--------------------------------------------------------------------------- */

-- Empleados en vacaciones dentro de un rango
IF OBJECT_ID('HR.sp_EmployeesOnLeave','P') IS NOT NULL DROP PROCEDURE HR.sp_EmployeesOnLeave;
GO
